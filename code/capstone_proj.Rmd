---
title: "Racial Disparities in School Discipline: Explorer Dashboard"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
runtime: shiny
---

```{r setup, include=FALSE}
# 
# install.packages("flexdashboard")
# install.packages("shiny")
# install.packages("leaflet")
# install.packages("plotly")
# install.packages("DT")
# install.packages("forecast")
#Load required libraries
library(flexdashboard)
library(shiny)
library(leaflet)
library(plotly)
library(dplyr)
library(ggplot2)
library(forecast)  # For time-series analysis
library(DT)  # For displaying data tables
library(rio)
```


```{r}
# AdvancED Equity Brand Theme for R Visualizations
# Created: January 2025
# Based on Visual Brand Guidelines February 2024
# Tried Seaford after installing again

# Required packages
# library(ggplot2)
library(tibble)
# windowsFonts(Seaford = windowsFont("Seaford")) 

library(showtext)
library(extrafont)

# Manually add Seaford (update with the correct font path)
font_add("Seaford", "~/Library/Group Containers/UBF8T346G9.Office/FontCache/4/CloudFonts/Seaford/19722397430.ttf")  
# Enable showtext rendering
showtext_auto()
#===============================
# Brand Color Definitions
#===============================
brand_colors <- list(
  dark_gray = "#303333",  # PMS 179-15-C
  yellow = "#e5de54",     # PMS 1-15 C
  sage = "#808c73",       # PMS 178-8 C
  gray = "#a1a1a1",       # PMS 179-7 C
  light_gray = "#bdbfbf"  # PMS 175-2 C
)

#===============================
# Color Palette Function
#===============================
brand_palette <- function(n = 5) {
  colors <- c(brand_colors$dark_gray, 
              brand_colors$yellow,
              brand_colors$sage,
              brand_colors$gray,
              brand_colors$light_gray)
  colors[1:n]
}

#===============================
# Brand Theme Definition
#===============================
theme_brand <- function(base_size = 12) {
  theme_minimal(base_size = base_size) %+replace%
    theme(
      # Text elements
      text = element_text(family = "Seaford"),  # Seaford
      plot.title = element_text(
        size = rel(1.2), 
        face = "bold"
      ),
      plot.subtitle = element_text(
        size = rel(1)
      ),
      axis.title = element_text(
        face = "bold"
      ),
      
      # Grid elements
      panel.grid.major = element_line(color = brand_colors$light_gray),
      panel.grid.minor = element_blank(),
      
      # Legend
      legend.position = "bottom"
    )
}

#===============================
# Scale Functions
#===============================
# For categorical colors
scale_fill_brand <- function(...) {
  scale_fill_manual(values = brand_palette(), ...)
}

scale_color_brand <- function(...) {
  scale_color_manual(values = brand_palette(), ...)
}

```







National Trends {data-height=350}

Out-of-School Suspension Rates

```{r}

## Read in data 
library(here)
df1 <- import(here("data/corp_76to20_bystate_MGyearrecoded.xlsx"))
df2 <- import(here("data/suspensions_72to21_bystate_MGyearrecoded.xlsx"))
df3 <- import(here("data/treatment dataset_2year.xlsx"))


#summary(df2$YEAR)
# YEAR ranges from 1972-2020
# summary(df2)
# df2$race_fact <- as.factor(df2$race)

```


```{r}

# Filter the data to include only relevant races (Black, White, AIAN)
filtered_data <- df2 %>%
  filter(race %in% c("BL", "WH", "AI"))

# Pivot the data to create columns for each race's percentage (`pct_`) by year
pivoted_data <- filtered_data %>%
  group_by(YEAR, race) 

#Turning NA into 0s
pivoted_data$pct_ <- ifelse(is.na(pivoted_data$pct_), 0, pivoted_data$pct_)

```

```{r}

#### Regular line plots. had to map it out this way first. 

# Check data directly (without pivot)
library(tidyr)
plot_data <- filtered_data %>%
  filter(race %in% c("BL", "WH", "AI")) %>%
  group_by(YEAR, race) %>%
  summarise(mean_pct = mean(pct_, na.rm = TRUE)) 

pivot_data <- plot_data %>%
  pivot_wider(names_from = race, values_from = mean_pct)


# Reshape data from wide to long format
long_data <- pivot_data%>%
  pivot_longer(cols = c(AI, BL, WH), names_to = "Race", values_to = "SuspensionRate")


library(hrbrthemes)
library(viridis)

long_data %>% 
  ggplot( aes(x=YEAR, y= SuspensionRate, group=Race, color=Race)) +
    geom_line() +
    scale_color_viridis(discrete = TRUE) +
    ggtitle("Out of School Suspension Rates over 50 years by Race") +
    theme_ipsum() +
    ylab("Suspension Rates (%)") +
  xlab("Year") +
  theme_minimal()

# long_data %>% 
#   ggplot( aes(x=YEAR, y= SuspensionRate, group=Race, color=Race)) +
#      geom_line(alpha = 0.6) +
#   geom_smooth(method = "loess", se = FALSE, span = 0.7) +
#   scale_fill_gradientn(
#     colors = c(brand_colors$light_gray, brand_colors$sage, brand_colors$dark_gray),
#     guide = "colorbar"
#   ) +
#   theme_brand() +
#   labs(
#     title = "Out of School Suspension Rates over 50 years by Race",
#     x = "Year",
#     y = "Suspension Rates (%)"
#   )

long_data %>% 
  ggplot(aes(x = YEAR, y = SuspensionRate, group = Race, color = Race)) +
  geom_line(alpha = 0.6) + 
  geom_smooth(method = "loess", se = FALSE, span = 0.7) +
  
  # Assign specific colors to each Race category
  scale_color_manual(
    values = c(
      "AI" = brand_colors$light_gray, 
      "BL" = brand_colors$sage, 
      "WH" = brand_colors$dark_gray
    )
  ) +
  
  theme_brand() + 
  labs(
    title = "Out of School Suspension Rates over 50 Years by Race",
    x = "Year",
    y = "Suspension Rates (%)"
  )

```

```{r}
####### Plotly interactive plots, can expand upon this to add more racial categories and potentially states somehow

### something went wrong here, trying to fix. did work at one point 

# Calculate smoothed values for each Race group using LOESS
long_data$Race <- as.factor(long_data$Race)
smoothed_data <- long_data %>%
  group_by(Race) %>%
  mutate(Smoothed = predict(loess(SuspensionRate ~ YEAR, span = 0.3)))


```

```{r}
library(plotly)
library(dplyr)

# # Ensure Race is a factor
# long_data$Race <- as.factor(long_data$Race)
# 
# # Calculate smoothed values using LOESS
# smoothed_data <- long_data %>%
#   group_by(Race) %>%
#   mutate(Smoothed = predict(loess(SuspensionRate ~ YEAR, span = 0.3)))

# Define custom colors for each race category
custom_colors <- c(
  "AI" = brand_colors$light_gray, 
  "BL" = brand_colors$sage, 
  "WH" = brand_colors$dark_gray
)

# Create the Plotly interactive plot
fig <- plot_ly(
  data = long_data, 
  x = ~YEAR, 
  y = ~SuspensionRate, 
  color = ~Race, 
  colors = custom_colors,  # Assign custom colors
  type = 'scatter', 
  mode = 'lines',
  showlegend = TRUE,
  name = ~Race
) %>% 
  add_trace(
    data = smoothed_data, 
    x = ~YEAR, 
    y = ~Smoothed, 
    color = ~Race, 
    colors = custom_colors,  # Assign same colors to smoothed lines
    type = 'scatter', 
    mode = 'lines',
    showlegend = FALSE  # Hide duplicate legend entries
  ) %>% 
  layout(
    title = "Out of School Suspension Rates over 50 Years by Race",
    xaxis = list(title = "Year"),
    yaxis = list(title = "Suspension Rates (%)"),
    legend = list(title = list(text = "Race"))
  )

fig  # Display the plot
```


STILL WORKING ON THE REST... 

Geospatial Trends {data-height=650}

Disparities by state or District
CO- bans and OSS
overall state trend by race for these disciplinary actions, see the data, but not download, line graphs to show up for different states when clicking on.

how should the map be displayed (four panels):
- sage and yellow for primary colors 
- 
first(static)- map, all states, two diff colors, states adopted ban and not (2020, df3)
2nd (static)- which states have banned and have not (2020, df3$ T_YEAR, year state adopted ban, ) OSS and (Separate) CP rate at national level, static, look like across the country, then pick from state, changes based on state graphs by race ethnicity changes based on which state they're picking 
2nd- this trend, state time, trend for OP
3rd/4th- Predictor: if the state had banned corp punishment, what would have been
 
use a parapmeter to loop in to the map, 


```{r}

```

```{r, eval=FALSE}
str(df1)

# Placeholder map: replace with actual geospatial data
states <- maps::map("state", fill = TRUE, plot = FALSE)
leafletOutput("discipline_map", height = 650)

discipline_map <- renderLeaflet({
  leaflet(data = states) %>%
    addTiles() %>%
    addPolygons(fillColor = ~rainbow(length(states$names))[as.numeric(as.factor(states$names))],
                color = "white", weight = 2) %>%
    addLegend("bottomright", colors = c("red", "blue", "green"),
              labels = c("High Disparity", "Medium Disparity", "Low Disparity"),
              title = "Discipline Disparity Levels")
})
discipline_map
```

```{r}
### Static map showing bi-color of CORP_ adopted by states for after 2020 
summary(df3)
# Filter dataset to only include years after 2020
df_corp <- df3 %>%
  filter(YEAR > 2020) %>%
  group_by(STATE_CODE)

# Aggregate data to determine the highest CORP_ status per state (i.e., if a state ever adopted the ban)
# df_map <- df1 %>%
#   group_by(STATE_CODE) %>%
#   summarise(CORP_status = max(CORP_, na.rm = TRUE))  # If at any point CORP_ was 1, assign 1


#### Adding maps to dataset 
# install.packages("maps")
library(maps)

# Define color palette
## Already done as brand color

us_states <- map_data("state")  # Built-in state map

# Convert state names to lowercase for merging
us_states$region <- tolower(us_states$region)

# Create a lookup table for state abbreviations and full names
state_lookup <- data.frame(STATE_CODE = state.abb, region = tolower(state.name))
state_lookup <- state_lookup %>%
  mutate(STATE_CODE = as.character(STATE_CODE), region = as.character(region)) %>%
  bind_rows(data.frame(STATE_CODE = "DC", region = "district of columbia"))
# Merge df_map with full state names
df_corp <- left_join(df_corp, state_lookup, by = "STATE_CODE")

## STATE_CODE has 51 states DC is counted as a state, but shows up as NA in region
## recoded region's NAs to be DC, dc

df_corp$region <- if_else(is.na(df_corp$region), "dc", df_corp$region)

unique(us_states$region)
  
# Merge with map data
us_states <- left_join(us_states, df_corp, by = "region")


color_palette <- list(yellow = "#e5de54", # not adopted 
                   dark_gray = "#808c73") # adopted
map_color_palette <- c("0" = color_palette$yellow, "1" = color_palette$dark_gray)
# summary(us_states)
# modelsummary::datasummary_skim(us_states, type = "all")

# ggplot() +
#   geom_polygon(data = us_states, aes(x = long, y = lat, group = group, fill = as.factor(DD)), 
#                color = brand_colors$dark_gray, size = 0.3) +  #dark_gray border for state separation
#    # Assign specific colors to each Race category
#   scale_color_manual(
#     values = c(
#       "Not Adopted" = brand_colors$yellow, 
#       "Adopted" = brand_colors$sage, 
#     )
#   ) +
#   
#   theme_brand() + 
#   labs(
#     title = "Out of School Suspension Rates over 50 Years by Race",
#     x = "Year",
#     y = "Suspension Rates (%)"
#   )

### Combine DC and Virginia for now


```

```{r}
### using ggplot 
library(ggplot2)

ggplot() +
  geom_polygon(
    data = us_states,
    aes(x = long, y = lat, group = group, fill = as.factor(DD)),
    color = "white", size = 0.3  # Add white borders for better distinction
  ) +
  scale_fill_manual(
    values = map_color_palette,
    labels = c("Not Adopted", "Adopted")
  ) +
  theme_minimal() +
  labs(
    title = "Corporal Punishment Ban Adoption by State",
    subtitle = "States that adopted bans starting in 2020",
    fill = "Ban Status"
  ) +
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  )
```

```{r}
## Ex. using leaflet 

library(leaflet)

# Load example data (or use your own dataset)
data <- map_data("state")

# Create a leaflet map
leaflet(data) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~colorBin("YlOrRd", density)(density),  # Replace `density` with your data
    color = "white",
    weight = 2,
    opacity = 1,
    fillOpacity = 0.7,
    highlight = highlightOptions(
      weight = 3,
      color = "#666",
      bringToFront = TRUE
    ),
    label = ~paste("State:", region, "<br>Density:", density)
  ) %>%
  addLegend(
    pal = colorBin("YlOrRd", data$density),
    values = data$density,
    title = "Density",
    position = "bottomright"
  )
```

```{r}
#install.packages("mapdeck")
library(mapdeck)

# Set your Mapbox access token
set_token("YOUR_MAPBOX_ACCESS_TOKEN")

# Create a simple map

summary(us_states)
mapdeck(style = mapdeck_style("dark")) %>%
  add_polygon(
    data = us_states,  # Replace with your spatial dataset
    layer_id = "choropleth",
    fill_colour = "density",  # Column for population density or any numeric variable
    palette = "viridis",      # Color palette
    legend = TRUE
  )
```

Policy Impact Predictions {data-height=350}

Predicting Discipline Outcomes Based on Policy Changes

```{r, eval=FALSE}
# Placeholder data for policy simulation
policies <- c("No Change", "Restorative Practices", "Corporal Punishment Ban")
predicted_disparities <- c(15, 10, 5)  # Placeholder predictions

# UI for user to select policy
selectInput("policy", "Select Policy:", choices = policies)

# Prediction Output
policy_prediction <- renderText({
  policy <- input$policy
  disparity <- predicted_disparities[which(policies == policy)]
  paste("Under the", policy, "policy, the predicted racial/ethnic disparity in discipline rates is", disparity, "%.")
})
textOutput("policy_prediction")
```


Explore the Data {data-height=400}

Raw Data Table

```{r, eval=FALSE}
# Example raw data
discipline_data <- data.frame(
  Year = rep(1970:2020, each = 3),
  Group = rep(c("Black", "White", "AIAN"), times = length(1970:2020)),
  SuspensionRate = rnorm(153, mean = 5, sd = 2)
)

output$data_table <- renderDT({
  datatable(discipline_data, options = list(pageLength = 10))
})
DTOutput("data_table")
```

Predictive Modeling {data-height=350}

Time-Series Forecasting
```{r, eval=FALSE}
# Example ARIMA model for forecasting
forecast_plot <- renderPlotly({
  ts_data <- ts(suspension_rates$Black, start = 1970, frequency = 1)
  model <- auto.arima(ts_data)
  forecasted <- forecast(model, h = 10)
  
  forecast_df <- data.frame(
    Year = seq(2021, 2030, by = 1),
    Predicted = forecasted$mean
  )
  
  plot_ly() %>%
    add_lines(x = suspension_rates$Year, y = suspension_rates$Black, name = "Actual", line = list(color = "blue")) %>%
    add_lines(x = forecast_df$Year, y = forecast_df$Predicted, name = "Forecast", line = list(color = "red")) %>%
    layout(title = "Suspension Rate Forecast",
           xaxis = list(title = "Year"),
           yaxis = list(title = "Suspension Rate (%)"))
})
plotlyOutput("forecast_plot")
```



Future Directions

	•	Expand Geospatial Data: Incorporate district-level data for finer granularity.
	•	User Scenarios: Add interactive tools for users to adjust variables like demographics, funding, or policy enforcement.
	•	Equity Metrics: Implement indices and scores to quantify equity improvements under different interventions.
	•	Machine Learning Models: Integrate additional models to predict outcomes like graduation rates or longer-term impacts of disciplinary disparities.